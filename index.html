<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wastewater Network Designer</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --accent: #38bdf8;
      --muted: #cbd5e1;
      --danger: #ef4444;
      --success: #22c55e;
      --warning: #f97316;
      --card: #1f2937;
      --text: #e2e8f0;
    }

    * {
      box-sizing: border-box;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, rgba(56, 189, 248, 0.12), transparent 25%),
        radial-gradient(circle at 80% 0%, rgba(99, 102, 241, 0.1), transparent 28%),
        var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      display: grid;
      grid-template-columns: 320px 1fr 320px;
      grid-template-rows: auto 1fr;
      grid-template-areas:
        "header header header"
        "sidebar canvas inspector";
      gap: 12px;
      padding: 12px;
    }

    header {
      grid-area: header;
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.18), rgba(56, 189, 248, 0));
      border: 1px solid rgba(56, 189, 248, 0.25);
      border-radius: 12px;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.35);
    }

    header h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.5px;
    }

    .k-control {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--panel);
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 8px 12px;
      border-radius: 10px;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
    }

    .k-control input {
      width: 80px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: #0b1221;
      color: var(--text);
    }

    .sidebar,
    .inspector {
      background: var(--panel);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
    }

    .sidebar {
      grid-area: sidebar;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .inspector {
      grid-area: inspector;
    }

    #canvas {
      grid-area: canvas;
      background: linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px),
        linear-gradient(0deg, rgba(255,255,255,0.02) 1px, transparent 1px);
      background-size: 40px 40px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 12px;
      position: relative;
      overflow: hidden;
    }

    .panel-title {
      font-weight: 700;
      letter-spacing: 0.4px;
      margin-bottom: 8px;
    }

    .node-button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: var(--card);
      color: var(--text);
      text-align: left;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .node-button:hover {
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .node-button.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.2);
    }

    .badge {
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 11px;
      background: rgba(56, 189, 248, 0.15);
      border: 1px solid rgba(56, 189, 248, 0.3);
      color: var(--text);
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .action-btn {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: #0b1221;
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .action-btn:hover {
      border-color: var(--accent);
    }

    .property-group {
      margin-bottom: 12px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      padding-bottom: 12px;
    }

    .property-group:last-child {
      border-bottom: none;
      padding-bottom: 0;
      margin-bottom: 0;
    }

    label {
      display: block;
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    input[type="text"],
    select,
    input[type="number"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: #0b1221;
      color: var(--text);
    }

    .inspector h3 {
      margin-top: 0;
    }

    .stat {
      display: grid;
      grid-template-columns: auto auto;
      align-items: center;
      margin-bottom: 8px;
    }

    .stat strong {
      text-align: right;
    }

    svg {
      width: 100%;
      height: 100%;
      cursor: default;
    }

    .node {
      filter: drop-shadow(0 6px 10px rgba(0, 0, 0, 0.45));
      transition: transform 0.15s ease;
    }

    .node rect {
      fill: var(--card);
      stroke: rgba(148, 163, 184, 0.35);
      stroke-width: 1.5;
    }

    .node text {
      fill: var(--text);
      font-weight: 600;
    }

    .port {
      stroke: #0b1221;
      stroke-width: 1.4;
      cursor: pointer;
    }

    .port.input {
      fill: #6366f1;
    }

    .port.output {
      fill: #22c55e;
    }

    .edge {
      fill: none;
      stroke: var(--muted);
      opacity: 0.9;
      transition: stroke 0.2s ease, stroke-width 0.2s ease;
    }

    .edge.connected-wc {
      stroke: var(--accent);
    }

    .edge-label {
      fill: var(--text);
      font-size: 12px;
      paint-order: stroke;
      stroke: rgba(15, 23, 42, 0.65);
      stroke-width: 2px;
    }

    .selection {
      stroke: var(--accent);
      stroke-width: 2.2;
      fill: none;
      stroke-dasharray: 4 2;
    }

    .info {
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .pill {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      margin-right: 6px;
      font-size: 12px;
    }

    .zone {
      stroke-width: 2;
      fill-opacity: 0.08;
      cursor: move;
    }

    .zone.building { stroke: #f59e0b; fill: #f59e0b; }
    .zone.floor { stroke: #10b981; fill: #10b981; }
    .zone.room { stroke: #6366f1; fill: #6366f1; }
    .zone-label { fill: var(--text); font-weight: 700; pointer-events: none; }
  </style>
</head>
<body>
  <header>
    <h1>Wastewater Network Designer</h1>
    <div class="k-control">
      <span class="muted">Contemporary factor (k)</span>
      <input id="kInput" type="number" min="0" step="0.01" value="1.0" />
      <button class="action-btn" id="recalc">Recalculate</button>
    </div>
  </header>

  <div class="sidebar">
    <div>
      <div class="panel-title">Palette</div>
      <div class="info">
        <div class="pill">Create</div>
        Click a button, then tap the canvas to add a node. Drag nodes to reposition. Connect outputs to inputs only.
      </div>
    </div>
    <div class="actions">
      <button class="action-btn" data-zone="building">Add building</button>
      <button class="action-btn" data-zone="floor">Add floor</button>
      <button class="action-btn" data-zone="room">Add room</button>
    </div>
    <div class="muted">Zones help organize the network. You can place nodes anywhere, but grouping them in zones keeps things tidy.</div>
    <button class="node-button" data-type="source">
      <span class="badge">Source</span>
      <div>
        <div>Sanitary Fixture</div>
        <div class="muted">WC, Lavabo, Doccia, …</div>
      </div>
    </button>
    <button class="node-button" data-type="destination">
      <span class="badge">Destination</span>
      <div>
        <div>Outlet</div>
        <div class="muted">Terminal stack / discharge</div>
      </div>
    </button>
    <button class="node-button" data-type="twoSplit">
      <span class="badge">Split</span>
      <div>
        <div>Two-way merge</div>
        <div class="muted">Two inputs ➝ one output</div>
      </div>
    </button>
    <button class="node-button" data-type="threeSplit">
      <span class="badge">Split</span>
      <div>
        <div>Three-way merge</div>
        <div class="muted">Three inputs ➝ one output</div>
      </div>
    </button>
    <div>
      <div class="panel-title">Shortcuts</div>
      <div class="actions">
        <button class="action-btn" id="delete-selection">Delete selected</button>
        <button class="action-btn" id="clear-all">Clear all</button>
      </div>
    </div>
  </div>

  <div id="canvas">
    <svg id="svg" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <marker id="arrow" markerWidth="10" markerHeight="6" refX="10" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L10,3 L0,6 z" fill="#cbd5e1" />
        </marker>
        <marker id="arrow-wc" markerWidth="10" markerHeight="6" refX="10" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L10,3 L0,6 z" fill="var(--accent)" />
        </marker>
      </defs>
      <g id="zones"></g>
      <g id="edges"></g>
      <g id="nodes"></g>
    </svg>
  </div>

  <div class="inspector">
    <h3>Inspector</h3>
    <div id="inspector-content" class="muted">Select a node or pipe to view details.</div>
  </div>

  <script>
    const svg = document.getElementById('svg');
    const zonesLayer = document.getElementById('zones');
    const nodesLayer = document.getElementById('nodes');
    const edgesLayer = document.getElementById('edges');
    const inspector = document.getElementById('inspector-content');
    const kInput = document.getElementById('kInput');
    const recalcBtn = document.getElementById('recalc');

    const zoneDefaults = { building: { width: 1000, height: 700 }, floor: { width: 820, height: 560 }, room: { width: 640, height: 420 } };
    const zoneLabels = { building: 'Building', floor: 'Floor', room: 'Room' };
    const fixturePrefixes = {
      WC: 'WC',
      Lavabo: 'LB',
      Bidè: 'BI',
      Doccia: 'DO',
      Vasca: 'VA',
      Lavastoviglie: 'LS',
      Lavatrice: 'LT',
      Lavello: 'LA',
    };

    let nodes = [];
    let zones = [];
    let edges = [];
    let selected = null;
    let creationType = null;
    let creationZoneType = null;
    let draggingNode = null;
    let draggingZone = null;
    let dragOffset = { x: 0, y: 0 };
    let zoneDragOffset = { x: 0, y: 0 };
    let nodeDragStart = null;
    let zoneDragSnapshot = null;
    let pendingConnection = null;
    const prefixCounters = {};
    const zoneCounters = { building: 0, floor: 0, room: 0 };

    const sourceCatalog = [
      { id: 'WC', label: 'WC', flow: 2.5, diameter: 'DN110', wc: true },
      { id: 'Lavabo', label: 'Lavabo', flow: 0.5, diameter: 'DN50', wc: false },
      { id: 'Bide', label: 'Bidè', flow: 0.5, diameter: 'DN50', wc: false },
      { id: 'Doccia', label: 'Doccia', flow: 0.8, diameter: 'DN63', wc: false },
      { id: 'Vasca', label: 'Vasca', flow: 0.8, diameter: 'DN63', wc: false },
      { id: 'Lavastoviglie', label: 'Lavastoviglie', flow: 0.8, diameter: 'DN63', wc: false },
      { id: 'Lavatrice', label: 'Lavatrice', flow: 0.8, diameter: 'DN63', wc: false },
      { id: 'Lavello', label: 'Lavello', flow: 0.8, diameter: 'DN63', wc: false },
    ];

    function generateId(prefix) {
      return prefix + '_' + Math.random().toString(36).slice(2, 8);
    }

    function nextCode(prefix) {
      prefixCounters[prefix] = (prefixCounters[prefix] || 0) + 1;
      return `${prefix}${prefixCounters[prefix]}`;
    }

    function prefixForNode(node) {
      if (node.type === 'twoSplit') return 'Y';
      if (node.type === 'threeSplit') return 'W';
      if (node.type === 'destination') return 'DS';
      if (node.type === 'source') {
        const meta = sourceCatalog.find(s => s.id === node.data.sourceType) || sourceCatalog[0];
        return fixturePrefixes[meta.id] || 'ND';
      }
      return 'ND';
    }

    function assignNodeCode(node, force) {
      const prefix = prefixForNode(node);
      if (force || !node.code || !node.code.startsWith(prefix)) {
        node.code = nextCode(prefix);
      }
    }

    function nextZoneName(type) {
      zoneCounters[type] += 1;
      return `${zoneLabels[type]} ${zoneCounters[type]}`;
    }

    function setCreationType(type) {
      creationType = type;
      creationZoneType = null;
      document.querySelectorAll('.node-button').forEach(btn => btn.classList.toggle('active', btn.dataset.type === type));
      document.querySelectorAll('[data-zone]').forEach(btn => btn.classList.remove('active'));
    }

    function setZoneCreation(type) {
      creationZoneType = type;
      creationType = null;
      document.querySelectorAll('.node-button').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('[data-zone]').forEach(btn => btn.classList.toggle('active', btn.dataset.zone === type));
    }

    document.querySelectorAll('.node-button').forEach(btn => {
      btn.addEventListener('click', () => setCreationType(btn.dataset.type));
    });

    document.querySelectorAll('[data-zone]').forEach(btn => {
      btn.addEventListener('click', () => setZoneCreation(btn.dataset.zone));
    });

    function canvasPoint(evt) {
      const rect = svg.getBoundingClientRect();
      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }

    svg.addEventListener('click', evt => {
      const targetIsZone = evt.target.classList && evt.target.classList.contains('zone');
      const onCanvas = evt.target === svg || targetIsZone;
      if (onCanvas && creationType) {
        const pt = canvasPoint(evt);
        const created = createNode(creationType, pt.x, pt.y);
        if (created) {
          recompute();
          render();
          renderInspector();
        }
        return;
      }
      if (onCanvas && creationZoneType) {
        const pt = canvasPoint(evt);
        createZone(creationZoneType, pt.x, pt.y);
        render();
        return;
      }
    });

    function createNode(type, x, y) {
      const node = {
        id: generateId('n'),
        type,
        label: type === 'source' ? 'Source' : type === 'destination' ? 'Destination' : type === 'twoSplit' ? 'Two-way split' : 'Three-way split',
        x,
        y,
        data: {}
      };

      if (type === 'source') {
        node.data.sourceType = sourceCatalog[0].id;
      }

      assignNodeCode(node, true);
      nodes.push(node);
      assignNodeLocation(node);
      setCreationType(null);
      return true;
    }

    function getNodeById(id) {
      return nodes.find(n => n.id === id);
    }

    function getEdgesFrom(nodeId) {
      return edges.filter(e => e.from === nodeId);
    }

    function getEdgesTo(nodeId) {
      return edges.filter(e => e.to === nodeId);
    }

    function getZoneById(id) {
      return zones.find(z => z.id === id);
    }

    function zoneContains(zone, x, y) {
      return x >= zone.x && x <= zone.x + zone.width && y >= zone.y && y <= zone.y + zone.height;
    }

    function containingZone(type, x, y) {
      const matches = zones.filter(z => z.type === type && zoneContains(z, x, y));
      return matches.sort((a, b) => a.width * a.height - b.width * b.height)[0];
    }

    function assignNodeLocation(node) {
      const building = containingZone('building', node.x, node.y);
      const floor = containingZone('floor', node.x, node.y);
      const room = containingZone('room', node.x, node.y);
      node.buildingId = building?.id || null;
      node.floorId = floor?.id || null;
      node.roomId = room?.id || null;
      node.withinZones = Boolean(building && floor && room);
      return true;
    }

    function updateNodeLocations() {
      nodes.forEach(assignNodeLocation);
    }

    function zoneNameById(id) {
      const z = getZoneById(id);
      return z ? z.name : '';
    }

    function nodeLocation(node) {
      return {
        building: zoneNameById(node.buildingId),
        floor: zoneNameById(node.floorId),
        room: zoneNameById(node.roomId),
        valid: Boolean(node.buildingId && node.floorId && node.roomId),
      };
    }

    function applyZoneChange(mutator) {
      mutator();
      updateNodeLocations();
      return true;
    }

    function createZone(type, x, y) {
      const { width, height } = zoneDefaults[type];
      const zone = {
        id: generateId('z'),
        type,
        name: nextZoneName(type),
        x: x - width / 2,
        y: y - height / 2,
        width,
        height,
      };
      zones.push(zone);
      setZoneCreation(null);
      updateNodeLocations();
    }

    function portPositions(node) {
      const width = 140;
      const height = 70;
      const inputs = [];
      const outputs = [];

      if (node.type === 'source') {
        outputs.push({ x: node.x + width / 2, y: node.y });
      } else if (node.type === 'destination') {
        inputs.push({ x: node.x - width / 2, y: node.y });
      } else if (node.type === 'twoSplit') {
        inputs.push({ x: node.x - width / 2, y: node.y - 14 });
        inputs.push({ x: node.x - width / 2, y: node.y + 14 });
        outputs.push({ x: node.x + width / 2, y: node.y });
      } else if (node.type === 'threeSplit') {
        inputs.push({ x: node.x - width / 2, y: node.y - 20 });
        inputs.push({ x: node.x - width / 2, y: node.y });
        inputs.push({ x: node.x - width / 2, y: node.y + 20 });
        outputs.push({ x: node.x + width / 2, y: node.y });
      }

      return { inputs, outputs, width, height };
    }

    function allowedInputCount(node) {
      if (node.type === 'twoSplit') return 2;
      if (node.type === 'threeSplit') return 3;
      return Infinity;
    }

    function handlePortClick(node, portType, evt) {
      evt.stopPropagation();
      if (portType === 'output') {
        pendingConnection = { from: node.id };
        setSelected(null);
      } else if (portType === 'input') {
        if (!pendingConnection) return;
        if (pendingConnection.from === node.id) return;
        const incoming = getEdgesTo(node.id).length;
        if (incoming >= allowedInputCount(node)) {
          alert('Input capacity reached for this node.');
          pendingConnection = null;
          return;
        }
        edges.push({ id: generateId('e'), from: pendingConnection.from, to: node.id });
        pendingConnection = null;
        recompute();
        render();
      }
    }

    function setSelected(item) {
      selected = item;
      renderInspector();
      render();
    }

    function renderInspector() {
      if (!selected) {
        inspector.innerHTML = '<div class="muted">Select a node or pipe to view details.</div>';
        return;
      }

      if (selected.type === 'edge') {
        const edge = edges.find(e => e.id === selected.id);
        const from = getNodeById(edge.from);
        const to = getNodeById(edge.to);
        const flowExplanation = describeEdgeFlow(edge, from);
        const diameterExplanation = describeEdgeDiameter(edge, from);
      inspector.innerHTML = `
        <div class="property-group">
          <div class="panel-title">Pipe</div>
          <div class="muted">${from.label} ➝ ${to.label}</div>
        </div>
          <div class="property-group">
            <div class="stat"><span>Flow rate (Q)</span><strong>${(edge.flowRate ?? 0).toFixed(2)} l/s</strong></div>
            <div class="stat"><span>Diameter</span><strong>${edge.diameter || '—'}</strong></div>
            <div class="stat"><span>Connected to WC</span><strong>${edge.isConnectedToWC ? 'Yes' : 'No'}</strong></div>
            <div class="muted">${flowExplanation}</div>
            <div class="muted">${diameterExplanation}</div>
          </div>
          <button class="action-btn" onclick="deleteEdge('${edge.id}')">Delete pipe</button>
        `;
        return;
      }

      if (selected.type === 'zone') {
        const zone = getZoneById(selected.id);
        if (!zone) return;
        inspector.innerHTML = `
          <div class="property-group">
            <div class="panel-title">${zoneLabels[zone.type]} zone</div>
            <label>Name</label>
            <input type="text" value="${zone.name}" oninput="renameZone('${zone.id}', this.value)" />
          </div>
          <div class="property-group">
            <label>Position (x, y)</label>
            <div class="stat"><span>X</span><strong><input type="number" value="${zone.x.toFixed(0)}" oninput="updateZonePosition('${zone.id}', 'x', this.value)" /></strong></div>
            <div class="stat"><span>Y</span><strong><input type="number" value="${zone.y.toFixed(0)}" oninput="updateZonePosition('${zone.id}', 'y', this.value)" /></strong></div>
          </div>
          <div class="property-group">
            <label>Size (width, height)</label>
            <div class="stat"><span>Width</span><strong><input type="number" value="${zone.width.toFixed(0)}" oninput="updateZoneDimension('${zone.id}', 'width', this.value)" /></strong></div>
            <div class="stat"><span>Height</span><strong><input type="number" value="${zone.height.toFixed(0)}" oninput="updateZoneDimension('${zone.id}', 'height', this.value)" /></strong></div>
          </div>
          <button class="action-btn" onclick="deleteZone('${zone.id}')">Delete zone</button>
        `;
        return;
      }

      const node = getNodeById(selected.id);
      const locationInfo = nodeLocation(node);
      let extraFields = '';

      if (node.type === 'source') {
        const options = sourceCatalog.map(s => `<option value="${s.id}" ${node.data.sourceType === s.id ? 'selected' : ''}>${s.label} (${s.flow} l/s, ${s.diameter})</option>`).join('');
        extraFields = `
          <label>Fixture type</label>
          <select onchange="updateSourceType('${node.id}', this.value)">${options}</select>
        `;
      } else if (node.type === 'destination') {
        extraFields = `
          <label>Design flow (optional)</label>
          <input type="number" step="0.1" value="${node.data.designFlow ?? ''}" oninput="updateDestinationFlow('${node.id}', this.value)" />
        `;
      }

      inspector.innerHTML = `
        <div class="property-group">
          <div class="panel-title">${node.label}</div>
          <label>Name</label>
          <input type="text" value="${node.label}" oninput="renameNode('${node.id}', this.value)" />
        </div>
        <div class="property-group">
          <div class="stat"><span>System name</span><strong>${node.code}</strong></div>
        </div>
        ${extraFields ? `<div class="property-group">${extraFields}</div>` : ''}
        <div class="property-group">
          <div class="stat"><span>Building</span><strong>${locationInfo.building}</strong></div>
          <div class="stat"><span>Floor</span><strong>${locationInfo.floor}</strong></div>
          <div class="stat"><span>Room</span><strong>${locationInfo.room}</strong></div>
        </div>
        <div class="property-group">
          <div class="stat"><span>Outgoing flow</span><strong>${(node.computedFlow ?? 0).toFixed(2)} l/s</strong></div>
          <div class="stat"><span>WC influence</span><strong>${node.hasWC ? 'Yes' : 'No'}</strong></div>
        </div>
        <button class="action-btn" onclick="deleteNode('${node.id}')">Delete node</button>
      `;
    }

    window.renameZone = function (id, value) {
      const zone = getZoneById(id);
      if (!zone) return;
      zone.name = value || zone.name;
      updateNodeLocations();
      renderInspector();
      render();
    }

    window.updateZoneDimension = function (id, field, value) {
      const zone = getZoneById(id);
      if (!zone) return;
      const numeric = parseFloat(value);
      if (!numeric || numeric <= 0) return;
      applyZoneChange(() => { zone[field] = numeric; });
      render();
      renderInspector();
    }

    window.updateZonePosition = function (id, field, value) {
      const zone = getZoneById(id);
      if (!zone) return;
      const numeric = parseFloat(value);
      if (Number.isNaN(numeric)) return;
      applyZoneChange(() => { zone[field] = numeric; });
      render();
      renderInspector();
    }

    window.deleteZone = function (id) {
      applyZoneChange(() => { zones = zones.filter(z => z.id !== id); });
      setSelected(null);
      render();
      renderInspector();
    }

    window.renameNode = function (id, value) {
      const node = getNodeById(id);
      node.label = value || node.label;
      render();
    }

    window.updateSourceType = function (id, typeId) {
      const node = getNodeById(id);
      node.data.sourceType = typeId;
      assignNodeCode(node, true);
      recompute();
      render();
      renderInspector();
    }

    window.updateDestinationFlow = function (id, val) {
      const node = getNodeById(id);
      node.data.designFlow = val ? parseFloat(val) : null;
      renderInspector();
    }

    window.deleteNode = function (id) {
      nodes = nodes.filter(n => n.id !== id);
      edges = edges.filter(e => e.from !== id && e.to !== id);
      setSelected(null);
      recompute();
      render();
    }

    window.deleteEdge = function (id) {
      edges = edges.filter(e => e.id !== id);
      setSelected(null);
      recompute();
      render();
    }

    document.addEventListener('keydown', evt => {
      if (evt.target.tagName === 'INPUT' || evt.target.tagName === 'SELECT' || evt.target.tagName === 'TEXTAREA') return;
      if ((evt.key === 'Delete' || evt.key === 'Backspace') && selected) {
        if (selected.type === 'edge') {
          deleteEdge(selected.id);
        } else if (selected.type === 'zone') {
          deleteZone(selected.id);
        } else {
          deleteNode(selected.id);
        }
      }
    });

    document.getElementById('delete-selection').addEventListener('click', () => {
      if (!selected) return;
      if (selected.type === 'edge') {
        deleteEdge(selected.id);
      } else if (selected.type === 'zone') {
        deleteZone(selected.id);
      } else {
        deleteNode(selected.id);
      }
    });

    document.getElementById('clear-all').addEventListener('click', () => {
      if (confirm('Clear all nodes and pipes?')) {
        nodes = [];
        edges = [];
        setSelected(null);
        render();
      }
    });

    function diameterFromFlow(flow) {
      const rate = flow;
      if (rate < 0.5) return 'DN40';
      if (rate >= 0.5 && rate < 0.8) return 'DN50';
      if (rate >= 0.8 && rate < 1) return 'DN63';
      if (rate >= 1 && rate < 1.5) return 'DN75';
      if (rate >= 1.5 && rate < 2) return 'DN80';
      if (rate >= 2 && rate < 2.25) return 'DN90';
      return 'DN110';
    }

    function projectCoefficient() {
      const normalized = (kInput.value || '').replace(',', '.');
      const parsed = Number(normalized);
      if (!Number.isFinite(parsed) || parsed <= 0) return 1;
      return parsed;
    }

    function describeEdgeFlow(edge, fromNode) {
      if (!fromNode) return 'Upstream node missing; flow defaults to 0.00 l/s.';

      if (fromNode.type === 'source') {
        const meta = sourceCatalog.find(s => s.id === fromNode.data.sourceType) || sourceCatalog[0];
        return `Flow comes directly from source "${meta.label}" providing ${meta.flow.toFixed(2)} l/s.`;
      }

      const incoming = getEdgesTo(fromNode.id);
      const upstreamParts = incoming.map(e => (e.upstreamSourceFlow || 0).toFixed(2));
      const totalSourceFlow = upstreamParts.reduce((total, val) => total + parseFloat(val), 0);
      if (!incoming.length) return `No upstream pipes connected to ${fromNode.label}; flow remains 0.00 l/s.`;

      const k = projectCoefficient();
      const design = fromNode.type === 'destination' && fromNode.data.designFlow != null ? fromNode.data.designFlow : null;
      const scaled = Math.sqrt(totalSourceFlow) * k;
      const finalFlow = design != null ? Math.max(scaled, design) : scaled;
      const breakdown = upstreamParts.join(' + ');
      const designNote = design != null ? ` and compared against destination design flow ${design.toFixed(2)} l/s` : '';
      return `Flow equals √(sum of upstream source flows ${breakdown}) × project coefficient k=${k.toFixed(2)}${designNote}, resulting in ${(finalFlow || 0).toFixed(2)} l/s.`;
    }

    function describeEdgeDiameter(edge, fromNode) {
      if (edge.isConnectedToWC) return 'WC is present upstream, forcing pipe diameter to DN110.';
      if (!fromNode) return 'Diameter derived from default rules because upstream node is missing.';
      return `Diameter chosen from flow ${(edge.flowRate || 0).toFixed(2)} l/s using sizing table → ${edge.diameter || 'DN?'}.`;
    }

    function recompute() {
      updateNodeLocations();
      const indegree = new Map();
      nodes.forEach(n => {
        indegree.set(n.id, getEdgesTo(n.id).length);
        n.computedFlow = 0;
        n.upstreamSourceFlow = 0;
        n.hasWC = false;
      });

      const q = [];
      nodes.forEach(n => {
        if (n.type === 'source' || indegree.get(n.id) === 0) q.push(n);
      });

      const k = projectCoefficient();

      while (q.length) {
        const node = q.shift();
        const inEdges = getEdgesTo(node.id);
        const incomingSourceFlows = inEdges.map(e => e.upstreamSourceFlow || 0);
        const incomingWC = inEdges.some(e => e.isConnectedToWC);

        if (node.type === 'source') {
          const meta = sourceCatalog.find(s => s.id === node.data.sourceType) || sourceCatalog[0];
          node.computedFlow = meta.flow;
          node.upstreamSourceFlow = meta.flow;
          node.hasWC = meta.wc;
        } else if (node.type === 'twoSplit' || node.type === 'threeSplit' || node.type === 'destination') {
          const totalSourceFlow = incomingSourceFlows.reduce((a, b) => a + b, 0);
          const scaled = Math.sqrt(totalSourceFlow) * k;
          const designFlow = node.type === 'destination' && node.data.designFlow != null ? node.data.designFlow : null;
          node.computedFlow = designFlow != null ? Math.max(scaled, designFlow) : scaled;
          node.upstreamSourceFlow = totalSourceFlow;
          node.hasWC = incomingWC;
        }

        getEdgesFrom(node.id).forEach(e => {
          const target = getNodeById(e.to);
          e.upstreamSourceFlow = node.upstreamSourceFlow || 0;
          e.flowRate = node.computedFlow || 0;

          const meta = node.type === 'source' ? sourceCatalog.find(s => s.id === node.data.sourceType) : null;
          const baseDiameter = meta ? meta.diameter : diameterFromFlow(e.flowRate);
          const isWC = node.hasWC;
          e.isConnectedToWC = isWC;
          e.diameter = isWC ? 'DN110' : baseDiameter;

          target.hasWC = target.hasWC || e.isConnectedToWC;
          indegree.set(target.id, indegree.get(target.id) - 1);
          if (indegree.get(target.id) === 0) q.push(target);
        });
      }
    }

    function edgeThickness(diameter) {
      const numeric = parseInt(diameter.replace('DN', '')) || 50;
      return Math.max(2, numeric / 25);
    }

    function render() {
      zonesLayer.innerHTML = '';
      edgesLayer.innerHTML = '';
      nodesLayer.innerHTML = '';

      zones.forEach(zone => {
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('class', `zone ${zone.type}`);
        rect.setAttribute('x', zone.x);
        rect.setAttribute('y', zone.y);
        rect.setAttribute('width', zone.width);
        rect.setAttribute('height', zone.height);
        rect.addEventListener('mousedown', evt => startZoneDrag(zone, evt));
        rect.addEventListener('click', evt => {
          evt.stopPropagation();
          setSelected({ type: 'zone', id: zone.id });
        });
        zonesLayer.appendChild(rect);

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('class', 'zone-label');
        label.setAttribute('x', zone.x + 12);
        label.setAttribute('y', zone.y + 20);
        label.textContent = `${zone.name} · ${zoneLabels[zone.type]}`;
        zonesLayer.appendChild(label);

        if (selected && selected.type === 'zone' && selected.id === zone.id) {
          const outline = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          outline.setAttribute('class', 'selection');
          outline.setAttribute('x', zone.x - 4);
          outline.setAttribute('y', zone.y - 4);
          outline.setAttribute('width', zone.width + 8);
          outline.setAttribute('height', zone.height + 8);
          zonesLayer.appendChild(outline);
        }
      });

      edges.forEach(edge => {
        const from = getNodeById(edge.from);
        const to = getNodeById(edge.to);
        if (!from || !to) return;
        const fromPorts = portPositions(from);
        const toPorts = portPositions(to);
        const start = fromPorts.outputs[0];
        const end = toPorts.inputs[Math.min(toPorts.inputs.length - 1, getEdgesTo(to.id).indexOf(edge))] || toPorts.inputs[0];

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const d = `M ${start.x} ${start.y} C ${start.x + 60} ${start.y}, ${end.x - 60} ${end.y}, ${end.x} ${end.y}`;
        path.setAttribute('d', d);
        path.setAttribute('class', `edge ${edge.isConnectedToWC ? 'connected-wc' : ''}`);
        path.setAttribute('stroke-width', edgeThickness(edge.diameter || 'DN50'));
        path.setAttribute('marker-end', edge.isConnectedToWC ? 'url(#arrow-wc)' : 'url(#arrow)');
        path.addEventListener('click', evt => {
          evt.stopPropagation();
          setSelected({ type: 'edge', id: edge.id });
        });
        edgesLayer.appendChild(path);

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.setAttribute('class', 'edge-label');
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2 - 6;
        label.setAttribute('x', midX);
        label.setAttribute('y', midY);
        const flow = edge.flowRate ? edge.flowRate.toFixed(2) : '0.00';
        label.textContent = `${flow} l/s · ${edge.diameter || 'DN?'}`;
        edgesLayer.appendChild(label);

        if (selected && selected.type === 'edge' && selected.id === edge.id) {
          const outline = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          outline.setAttribute('d', d);
          outline.setAttribute('class', 'selection');
          edgesLayer.appendChild(outline);
        }
      });

      nodes.forEach(node => {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', 'node');
        g.setAttribute('transform', `translate(${node.x} ${node.y})`);
        const { width, height, inputs, outputs } = portPositions(node);

        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', -width / 2);
        rect.setAttribute('y', -height / 2);
        rect.setAttribute('rx', 12);
        rect.setAttribute('ry', 12);
        rect.setAttribute('width', width);
        rect.setAttribute('height', height);
        g.appendChild(rect);

        const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        title.setAttribute('x', 0);
        title.setAttribute('y', -6);
        title.setAttribute('text-anchor', 'middle');
        title.textContent = `${node.code ? node.code + ' · ' : ''}${node.label}`;
        g.appendChild(title);

        const metaText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        metaText.setAttribute('x', 0);
        metaText.setAttribute('y', 14);
        metaText.setAttribute('text-anchor', 'middle');
        metaText.setAttribute('fill', '#cbd5e1');
        if (node.type === 'source') {
          const meta = sourceCatalog.find(s => s.id === node.data.sourceType) || sourceCatalog[0];
          metaText.textContent = `${meta.label} · ${meta.flow} l/s · ${meta.diameter}`;
        } else if (node.type === 'destination') {
          metaText.textContent = `Demand ${node.data.designFlow ?? '—'} l/s`;
        } else {
          metaText.textContent = 'Merge outputs';
        }
        g.appendChild(metaText);

        inputs.forEach(pt => {
          const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          c.setAttribute('class', 'port input');
          c.setAttribute('r', 6);
          c.setAttribute('cx', pt.x - node.x);
          c.setAttribute('cy', pt.y - node.y);
          c.addEventListener('click', evt => handlePortClick(node, 'input', evt));
          g.appendChild(c);
        });

        outputs.forEach(pt => {
          const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          c.setAttribute('class', 'port output');
          c.setAttribute('r', 6);
          c.setAttribute('cx', pt.x - node.x);
          c.setAttribute('cy', pt.y - node.y);
          c.addEventListener('click', evt => handlePortClick(node, 'output', evt));
          g.appendChild(c);
        });

        g.addEventListener('mousedown', evt => startDrag(node, evt));
        g.addEventListener('click', evt => {
          evt.stopPropagation();
          setSelected({ type: 'node', id: node.id });
        });

        nodesLayer.appendChild(g);

        if (selected && selected.type === 'node' && selected.id === node.id) {
          const outline = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          outline.setAttribute('class', 'selection');
          outline.setAttribute('x', -width / 2 - 4);
          outline.setAttribute('y', -height / 2 - 4);
          outline.setAttribute('rx', 14);
          outline.setAttribute('ry', 14);
          outline.setAttribute('width', width + 8);
          outline.setAttribute('height', height + 8);
          g.appendChild(outline);
        }
      });
    }

    function startDrag(node, evt) {
      draggingNode = node;
      nodeDragStart = { x: node.x, y: node.y };
      const pt = canvasPoint(evt);
      dragOffset.x = node.x - pt.x;
      dragOffset.y = node.y - pt.y;
      document.addEventListener('mousemove', onDrag);
      document.addEventListener('mouseup', endDrag);
    }

    function onDrag(evt) {
      if (!draggingNode) return;
      const pt = canvasPoint(evt);
      draggingNode.x = pt.x + dragOffset.x;
      draggingNode.y = pt.y + dragOffset.y;
      render();
    }

    function endDrag() {
      if (draggingNode) assignNodeLocation(draggingNode);
      draggingNode = null;
      document.removeEventListener('mousemove', onDrag);
      document.removeEventListener('mouseup', endDrag);
      recompute();
    }

    function startZoneDrag(zone, evt) {
      draggingZone = zone;
      zoneDragSnapshot = zones.map(z => ({ ...z }));
      const pt = canvasPoint(evt);
      zoneDragOffset.x = zone.x - pt.x;
      zoneDragOffset.y = zone.y - pt.y;
      document.addEventListener('mousemove', onZoneDrag);
      document.addEventListener('mouseup', endZoneDrag);
    }

    function onZoneDrag(evt) {
      if (!draggingZone) return;
      const pt = canvasPoint(evt);
      draggingZone.x = pt.x + zoneDragOffset.x;
      draggingZone.y = pt.y + zoneDragOffset.y;
      render();
    }

    function endZoneDrag() {
      if (draggingZone) updateNodeLocations();
      draggingZone = null;
      zoneDragSnapshot = null;
      document.removeEventListener('mousemove', onZoneDrag);
      document.removeEventListener('mouseup', endZoneDrag);
      render();
      renderInspector();
    }

    recalcBtn.addEventListener('click', () => {
      recompute();
      render();
      renderInspector();
    });

    svg.addEventListener('click', () => setSelected(null));

    // Initial demo scene
    createZone('building', 560, 300);
    createZone('floor', 560, 300);
    createZone('room', 560, 300);

    createNode('source', 320, 200);
    createNode('source', 320, 320);
    createNode('twoSplit', 600, 260);
    createNode('destination', 880, 260);
    edges.push({ id: generateId('e'), from: nodes[0].id, to: nodes[2].id });
    edges.push({ id: generateId('e'), from: nodes[1].id, to: nodes[2].id });
    edges.push({ id: generateId('e'), from: nodes[2].id, to: nodes[3].id });

    recompute();
    render();
  </script>
</body>
</html>
